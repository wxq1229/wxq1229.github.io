<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AtCoder Regular Contest 101</title>
    <url>/2020/08/12/AtCoder-Regular-Contest-101/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/arc101">Link</a></p>
<a id="more"></a>
<h2 id="C-Candles"><a href="#C-Candles" class="headerlink" title="C. Candles"></a>C. Candles</h2><p>被点燃蜡烛一定在一个区间内，枚举这个区间计算即可</p>
<p>复杂度$\mathcal{O}(N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15829782">评测链接</a></p>
<h2 id="D-Median-of-Medians"><a href="#D-Median-of-Medians" class="headerlink" title="D. Median of Medians"></a>D. Median of Medians</h2><p>对于一个长度为$N$的序列，它的median一定满足以下条件：</p>
<ul>
<li>序列中小于等于median的数（包括本身）的个数$\times 2 &gt; N$</li>
<li>median应为满足上面那个条件的最小的数</li>
</ul>
<p>二分，假设二分到的数为$x$，问题变为找有多少$m_{l,r}$，满足$m_{l,r} \le x$。</p>
<p>$m_{l,r} \le x$当且仅当$A_l…A_r$内小于等于$x$的数的数量<strong>超过</strong>一半（不能等于）</p>
<p>构造一个序列$d$，如果$A_i \le x$那么$d_i=1$，否则$d_i=-1$</p>
<p>那么$m$ 数量即为$d$上区间和大于$1$的区间个数</p>
<p>对$d$做前缀和得到$s$（$s_0=0$），问题变为有多少有序对$(i,j)$，满足</p>
<ul>
<li>$0 \le i &lt; j \le N$ 且 $s_j&gt;s_i$</li>
</ul>
<p>树状数组计算顺序对的个数即可</p>
<p>复杂度$\mathcal{O}(N \log^2N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15831453">评测链接</a></p>
<h2 id="E-Ribbons-on-Tree"><a href="#E-Ribbons-on-Tree" class="headerlink" title="E. Ribbons on Tree"></a>E. Ribbons on Tree</h2><p>要求所有边都被覆盖到，不妨考虑容斥</p>
<p>定义$f(S)$表示满足下面条件的方案数：</p>
<ul>
<li>对于集合$S$中的边，一定不能被覆盖到，其他点随意两两匹配的方案数</li>
</ul>
<p>那么最后的答案即为$\sum_{S \subseteq E} (-1)^{\mid S\mid}f(S)$</p>
<p>如果限制了一条边不能被覆盖，那么就可以把这条边删去，这样会把树分成若干个连通块</p>
<p>那么$f(S)$就是每个连通块中点两两匹配的方案数的乘积</p>
<p>定义$g(N)$表示$N$个点两两匹配的方案数，那么有</p>
<script type="math/tex; mode=display">
g(N) = \begin{cases}
(N-1)(N-3)\cdots 1 \quad (2 \mid N) \\
0 \quad\quad\quad\quad\quad\quad\quad\quad \ \ \ \ \  (2 \not\mid N)
\end{cases}</script><p>即第$1$个点有$N-1$个点可供匹配，去除两个后剩下来的第二个待匹配点有$N-3$个点共匹配</p>
<p>考虑树形DP出上面那个式子的值</p>
<p>定义$dp(u,i)$表示在点$u$的子树中，点$u$所在连通块大小为$i$时对答案的贡献总和</p>
<p>枚举儿子$v$讨论割或者不割$(u,v)$这条边的贡献。如果割，那么要乘上一个$-1$的常数。</p>
<p>类似树上背包那样转移即可</p>
<p>复杂度$\mathcal{O}(N^2)$，<a href="https://atcoder.jp/contests/arc101/submissions/15659672">评测链接</a></p>
<h2 id="F-Robots-and-Exits"><a href="#F-Robots-and-Exits" class="headerlink" title="F. Robots and Exits"></a>F. Robots and Exits</h2><p>一个机器人只能从在他左边或右边最近的出口出去</p>
<p>同时删去在第一个出口左边、在最后一个出口右边和原来就在出口上的机器人不会影响答案（因为他们能匹配的出口就一个）</p>
<p>对于第$i$个机器人，令$x_i$表示它到它左边离它最近的出口的距离，$y_i$表示它到它右边离它最近的出口的距离</p>
<p>对于某一个时刻，影响一个机器人是否消失的因素总共有两个</p>
<ul>
<li>向左移动的总步数</li>
<li>向右移动的总步数</li>
</ul>
<p>不妨用一个二元组$(l,r)$表示当前状态</p>
<p>对于一个还未消失的机器人，如果它恰好在当前时刻消失，当且仅当$l=x$或$r=y$</p>
<p>如果是$l=x$那么表示它从左边的出口出去，否则就是从右边的</p>
<p>所有机器人可以对应到平面上两条直线，分别为$x=x_i$和$y=y_i$，并把$(x_i,y_i)$这个点放到平面上</p>
<p>刚开始的状态可以表示为$(0,0)$，每次可以使横坐标或纵坐标加一</p>
<p>如果碰到了一条直线，那么这条直线所代表的机器人就消失</p>
<ul>
<li>如果碰到的直线垂直于$x$轴，那么这个机器人就是从左出口走的</li>
<li>如果碰到的直线垂直于$y$轴，那么这个机器人就是从右出口走的</li>
</ul>
<p>考虑DP，令$dp_i$表示最后一个从右出口走的机器人是第$i$个机器人的匹配方案数</p>
<p>那么有转移$dp_i=1+\sum\limits_{x_j&lt;x_i,y_j&lt;y_i} dp_j$</p>
<p>枚举上一个从右出口走的机器人$j$（要保证这时候$i$还在），然后不断向上走使中间哪些机器人全部从左出口出去，再向右碰到$y=y_i$这条直线，使得$i$从右出口出去，最后加$1$是因为可以让在点$(x_i,y_i)$左下方的机器人都从左出口出去。</p>
<p>最后答案即为$1+\sum_{i=1}^N dp_i$（加$1$代表所有机器人都从左出口出去）</p>
<p>先按$x_i$为第一关键字（从小到大）$y_i$为第二关键字（<strong>从大到小</strong>）排序，用树状数组维护$y_i$的限制转移即可。</p>
<p>复杂度$\mathcal{O}(N \log N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15845816">评测链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Tokio Marine &amp; Nichido Fire Insurance Programming Contest 2020</title>
    <url>/2020/08/11/Tokio-Marine-Nichido-Fire-Insurance-Programming-Contest-2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/tokiomarine2020">Link</a></p>
<a id="more"></a>
<h2 id="A-Nickname"><a href="#A-Nickname" class="headerlink" title="A. Nickname"></a>A. Nickname</h2><p>难/kk，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15709689">评测链接</a></p>
<h2 id="B-Tag"><a href="#B-Tag" class="headerlink" title="B. Tag"></a>B. Tag</h2><p>难/kk， <a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15709850">评测链接</a></p>
<h2 id="C-Lamps"><a href="#C-Lamps" class="headerlink" title="C. Lamps"></a>C. Lamps</h2><p>发现有效的操作轮数不是很多，模拟到所有$A_i=N$即可，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15710108">评测链接</a></p>
<h2 id="D-Knapsack-Queries-on-a-tree"><a href="#D-Knapsack-Queries-on-a-tree" class="headerlink" title="D. Knapsack Queries on a tree"></a>D. Knapsack Queries on a tree</h2><p><del>有幸遇到了一道校内膜你赛的题</del></p>
<p>一次询问只会和当前点到根路径上的点有关，同时注意到前$\frac{1}{2}$层的节点总数在$\sqrt{N}$级别，后面的层数很少但节点却很多。</p>
<p>分块，DP预处理出前$1…S$个点在$L=1…10^5$时的答案，对于后面的点$2^n$暴力即可。</p>
<p>取$S=\sqrt{N}$，询问总复杂度$O(Q\sqrt N)$，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15710437">评测链接</a></p>
<h2 id="E-O-rand"><a href="#E-O-rand" class="headerlink" title="E. O(rand)"></a>E. O(rand)</h2><p>注意到一点，考虑$S$和$T$二进制下从右起第$i$位，分四种情况</p>
<ul>
<li><p>$S$当前位为$1$，$T$当前位为$0$，原地爆炸，$Ans=0$</p>
</li>
<li><p>$S$当前位为1，$T$当前位为$1$，那么就一定不能选这位为$0$的数</p>
</li>
<li><p>$S$当前位为$0$，$T$当前位为$0$，那么就一定不能选这位为$1$的数</p>
</li>
<li><p>$S$当前位为$0$，$T$当前位为$1$，既要选这一位为$1$的又要选这一位为$0$的</p>
</li>
</ul>
<p>判定无解或去除一定不会被选的数后问题变为$S=0$，$T=2^k-1$。</p>
<p>考虑容斥，令$f(U)$表示满足下面这个条件的方案的数量：</p>
<ul>
<li>若集合$U$中不包含元素$i$，那么对这一位没有要求</li>
<li>若集合$U$中包含元素$i$，那么选出的所有数$or$起来这一位不是$1$，或者$and$起来不为$0$</li>
</ul>
<p>答案即为$\sum_U (-1)^{\mid U\mid} f(U)$</p>
<p>考虑怎么计算$f(U)$，由于不关心$U$中不包含的二进制位，所以将所有$A_i$与上$U$，然后再计数。</p>
<p>这样过后$A_i$就只能和自己相同的$A_j$分在一组。</p>
<p>预处理出组合数前缀和，开个桶算下即可。</p>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15722626">评测链接</a></p>
<h2 id="F-Triangles"><a href="#F-Triangles" class="headerlink" title="F. Triangles"></a>F. Triangles</h2><p>不会，咕咕咕（</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>老博客链接</title>
    <url>/2020/08/11/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/</url>
    <content><![CDATA[<p>换blog辣~</p>
<a id="more"></a>
<p><a href="https://www.cnblogs.com/wxq1229">原来的博客</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
