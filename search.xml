<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tokio Marine &amp; Nichido Fire Insurance Programming Contest 2020</title>
    <url>/2020/08/11/Tokio-Marine-Nichido-Fire-Insurance-Programming-Contest-2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/tokiomarine2020">Link</a></p>
<a id="more"></a>
<h2 id="A-Nickname"><a href="#A-Nickname" class="headerlink" title="A. Nickname"></a>A. Nickname</h2><p>难/kk，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15709689">评测链接</a></p>
<h2 id="B-Tag"><a href="#B-Tag" class="headerlink" title="B. Tag"></a>B. Tag</h2><p>难/kk， <a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15709850">评测链接</a></p>
<h2 id="C-Lamps"><a href="#C-Lamps" class="headerlink" title="C. Lamps"></a>C. Lamps</h2><p>发现有效的操作轮数不是很多，模拟到所有$A_i=N$即可，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15710108">评测链接</a></p>
<h2 id="D-Knapsack-Queries-on-a-tree"><a href="#D-Knapsack-Queries-on-a-tree" class="headerlink" title="D. Knapsack Queries on a tree"></a>D. Knapsack Queries on a tree</h2><p><del>有幸遇到了一道校内膜你赛的题</del></p>
<p>一次询问只会和当前点到根路径上的点有关，同时注意到前$\frac{1}{2}$层的节点总数在$\sqrt{N}$级别，后面的层数很少但节点却很多。</p>
<p>分块，DP预处理出前$1…S$个点在$L=1…10^5$时的答案，对于后面的点$2^n$暴力即可。</p>
<p>取$S=\sqrt{N}$，询问总复杂度$O(Q\sqrt N)$，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15710437">评测链接</a></p>
<h2 id="E-O-rand"><a href="#E-O-rand" class="headerlink" title="E. O(rand)"></a>E. O(rand)</h2><p>注意到一点，考虑$S$和$T$二进制下从右起第$i$位，分四种情况</p>
<ul>
<li><p>$S$当前位为$1$，$T$当前位为$0$，原地爆炸，$Ans=0$</p>
</li>
<li><p>$S$当前位为1，$T$当前位为$1$，那么就一定不能选这位为$0$的数</p>
</li>
<li><p>$S$当前位为$0$，$T$当前位为$0$，那么就一定不能选这位为$1$的数</p>
</li>
<li><p>$S$当前位为$0$，$T$当前位为$1$，既要选这一位为$1$的又要选这一位为$0$的</p>
</li>
</ul>
<p>判定无解或去除一定不会被选的数后问题变为$S=0$，$T=2^k-1$。</p>
<p>考虑容斥，令$f(U)$表示满足下面这个条件的方案的数量：</p>
<ul>
<li>若集合$U$中不包含元素$i$，那么对这一位没有要求</li>
<li>若集合$U$中包含元素$i$，那么选出的所有数$or$起来这一位不是$1$，或者$and$起来不为$0$</li>
</ul>
<p>答案即为$\sum_U (-1)^{\mid U\mid} f(U)$</p>
<p>考虑怎么计算$f(U)$，由于不关心$U$中不包含的二进制位，所以将所有$A_i$与上$U$，然后再计数。</p>
<p>这样过后$A_i$就只能和自己相同的$A_j$分在一组。</p>
<p>预处理出组合数前缀和，开个桶算下即可。</p>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15722626">评测链接</a></p>
<h2 id="F-Triangles"><a href="#F-Triangles" class="headerlink" title="F. Triangles"></a>F. Triangles</h2><p>不会，咕咕咕（</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 101</title>
    <url>/2020/08/12/AtCoder-Regular-Contest-101/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/arc101">Link</a></p>
<a id="more"></a>
<h2 id="C-Candles"><a href="#C-Candles" class="headerlink" title="C. Candles"></a>C. Candles</h2><p>被点燃蜡烛一定在一个区间内，枚举这个区间计算即可</p>
<p>复杂度$\mathcal{O}(N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15829782">评测链接</a></p>
<h2 id="D-Median-of-Medians"><a href="#D-Median-of-Medians" class="headerlink" title="D. Median of Medians"></a>D. Median of Medians</h2><p>对于一个长度为$N$的序列，它的median一定满足以下条件：</p>
<ul>
<li>序列中小于等于median的数（包括本身）的个数$\times 2 &gt; N$</li>
<li>median应为满足上面那个条件的最小的数</li>
</ul>
<p>二分，假设二分到的数为$x$，问题变为找有多少$m_{l,r}$，满足$m_{l,r} \le x$。</p>
<p>$m_{l,r} \le x$当且仅当$A_l…A_r$内小于等于$x$的数的数量<strong>超过</strong>一半（不能等于）</p>
<p>构造一个序列$d$，如果$A_i \le x$那么$d_i=1$，否则$d_i=-1$</p>
<p>那么$m$ 数量即为$d$上区间和大于$1$的区间个数</p>
<p>对$d$做前缀和得到$s$（$s_0=0$），问题变为有多少有序对$(i,j)$，满足</p>
<ul>
<li>$0 \le i &lt; j \le N$ 且 $s_j&gt;s_i$</li>
</ul>
<p>树状数组计算顺序对的个数即可</p>
<p>复杂度$\mathcal{O}(N \log^2N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15831453">评测链接</a></p>
<h2 id="E-Ribbons-on-Tree"><a href="#E-Ribbons-on-Tree" class="headerlink" title="E. Ribbons on Tree"></a>E. Ribbons on Tree</h2><p>要求所有边都被覆盖到，不妨考虑容斥</p>
<p>定义$f(S)$表示满足下面条件的方案数：</p>
<ul>
<li>对于集合$S$中的边，一定不能被覆盖到，其他点随意两两匹配的方案数</li>
</ul>
<p>那么最后的答案即为$\sum_{S \subseteq E} (-1)^{\mid S\mid}f(S)$</p>
<p>如果限制了一条边不能被覆盖，那么就可以把这条边删去，这样会把树分成若干个连通块</p>
<p>那么$f(S)$就是每个连通块中点两两匹配的方案数的乘积</p>
<p>定义$g(N)$表示$N$个点两两匹配的方案数，那么有</p>
<script type="math/tex; mode=display">
g(N) = \begin{cases}
(N-1)(N-3)\cdots 1 \quad (2 \mid N) \\
0 \quad\quad\quad\quad\quad\quad\quad\quad \ \ \ \ \  (2 \not\mid N)
\end{cases}</script><p>即第$1$个点有$N-1$个点可供匹配，去除两个后剩下来的第二个待匹配点有$N-3$个点共匹配</p>
<p>考虑树形DP出上面那个式子的值</p>
<p>定义$dp(u,i)$表示在点$u$的子树中，点$u$所在连通块大小为$i$时对答案的贡献总和（不算$i$所在连通块的贡献）</p>
<p>枚举儿子$v$讨论割或者不割$(u,v)$这条边的贡献。如果割，那么要乘上一个$-1$的常数。</p>
<p>类似树上背包那样转移即可</p>
<p>复杂度$\mathcal{O}(N^2)$，<a href="https://atcoder.jp/contests/arc101/submissions/15659672">评测链接</a></p>
<h2 id="F-Robots-and-Exits"><a href="#F-Robots-and-Exits" class="headerlink" title="F. Robots and Exits"></a>F. Robots and Exits</h2><p>一个机器人只能从在他左边或右边最近的出口出去</p>
<p>同时删去在第一个出口左边、在最后一个出口右边和原来就在出口上的机器人不会影响答案（因为他们能匹配的出口就一个）</p>
<p>对于第$i$个机器人，令$x_i$表示它到它左边离它最近的出口的距离，$y_i$表示它到它右边离它最近的出口的距离</p>
<p>把这个点$(x_i,y_i)$放到直角坐标系下</p>
<p>在一个时刻，影响一个机器人是否消失的条件只有</p>
<ul>
<li>向左走走到最远的位置到原来位置的距离</li>
<li>向右走走到最远的位置到原来位置的距离</li>
</ul>
<p>不妨用一个二元组$(l,r)$来表示当前的状态</p>
<p>对于还未消失的机器人$i$，如果$l=x_i$或者$r=y_i$那么这个机器人就一定会在当前时刻消失，分别表示从左边/右边的出口出去</p>
<p>我们可以通过不断向左或向右移动，使得$(l,r) \rightarrow (l+1,r)$或$(l,r+1)$。</p>
<p>考虑一个DP，令$dp_i$表示最后一个从右边出去的机器人为$i$时的匹配方案数</p>
<p>有转移$dp_i = 1+\sum\limits_{x_j&lt;x_i,y_j&lt;y_i} dp_j$</p>
<p>即枚举上一个从右边出去的$j$（且$i$在这段时间内没有消失），然后一直使$l+1$让中间那段机器人从左边走，然后再向右让$i$从右边走掉。加$1$表示$i$是第一个从右边消失的机器人</p>
<p>然后答案即$1+\sum_{i=1}^N dp_i$（加$1$表示所有机器人都从左边走）</p>
<p>按照$x$为第一关键字（从小到大）$y$为第二关键字（<strong>从大到小</strong>）排序后用树状数组维护$y$的限制转移即可</p>
<p>复杂度$\mathcal{O}(N \log N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15845816">评测链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ551 【UNR #4】校园闲逛</title>
    <url>/2020/08/13/UOJ551-%E3%80%90UNR-4%E3%80%91%E6%A0%A1%E5%9B%AD%E9%97%B2%E9%80%9B/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/problem/551">Link</a></p>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑把邻接矩阵作为多项式的系数构造一个多项式</p>
<script type="math/tex; mode=display">
F(x) = \sum\limits_{i=1}^{maxv} A_ix^i</script><p>其中$A_i$表示仅由权值为$i$的边构成的图的邻接矩阵</p>
<p>枚举经过了多少条边，答案的生成函数就是</p>
<script type="math/tex; mode=display">
Ans(x) = 1+F(x)+F^2(x)+F^3(x) +\cdots = \frac{1}{1-F(x)}</script><p>（$Ans(x)$ $i$次项的系数是个矩阵，第$u$行第$v$列就表示$u \rightarrow v$，权值和为$i$的路径个数）</p>
<p>以上多项式的系数都是矩阵，但是显然不影响fft。</p>
<p>那怎么求逆呢？</p>
<p>注意到整数和矩阵有一个的区别就是矩阵乘法并不满足交换律，这里重新推下多项式求逆避免一些奇怪的结果</p>
<p>首先假设要对$F(x)$在$\bmod x^n$意义下求逆$G(x)$，即</p>
<script type="math/tex; mode=display">
F(x)G(x) \equiv I \pmod{x^n}</script><p>同时我们已经知道了$F(x)H(x) \equiv I \pmod{x^{\lceil \frac{n}{2}\rceil}}$</p>
<p>之前多项式求逆的时候有一种做法是把这两个式子作差，然后再提个$F(x)$得到</p>
<script type="math/tex; mode=display">
F(x)(G(x)-H(x)) \equiv 0 \pmod{x^{\lceil \frac{n}{2}\rceil}}</script><script type="math/tex; mode=display">
G(x)-H(x) \equiv 0 \pmod{x^{\lceil \frac{n}{2} \rceil}}</script><p>然后平方后把模变成$x^n$，用到了二项式定理，但这种多项式并不能这样展开，因为矩阵的乘法并不满足交换律从而它的卷积也不满足交换律，然后就并不能像那样用归纳法证明二项式定理</p>
<p><del>但好像这不足以说明它一定是错的，然而这样确实不能过样例</del></p>
<p>所以我们换个姿势：</p>
<script type="math/tex; mode=display">
F(x)H(x) - I \equiv 0 \pmod{x^{\lceil\frac{n}{2}\rceil}}</script><p>注意到这时候是能二项式定理的，因为$IA=AI$，满足交换律，开心（但要注意乘法的顺序</p>
<script type="math/tex; mode=display">
F(x)H(x)F(x)H(x) - 2F(x)H(x) + I \equiv 0 \pmod {x^n}</script><script type="math/tex; mode=display">
F(x)(H(x)F(x)H(x)-2H(x)) \equiv -I \pmod{x^n}</script><script type="math/tex; mode=display">
H(x)F(x)H(x)-2H(x) \equiv -F^{-1}(x) \pmod{x^n}</script><script type="math/tex; mode=display">
F^{-1}(x) \equiv 2H(x)-H(x)F(x)H(x) \pmod{x^n}</script><p>右边也就是那个$G(x)$</p>
<p>这样对$1-F(x)$求逆即可</p>
<p>复杂度$\mathcal{O}(n^3v \log v)$ <del>自带巨大常数</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = (ll) a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ll) ans * a % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = x + y - P; x += x &gt;&gt; <span class="number">31</span> &amp; P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>][<span class="number">8</span>], n, m;</span><br><span class="line"></span><br><span class="line">    mat(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>) &#123;</span><br><span class="line">        n = r, m = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) a[i][j] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="keyword">const</span> mat &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; o.n &lt;&lt; &quot; &quot; &lt;&lt; o.m &lt;&lt; endl;</span></span><br><span class="line">        assert(m == o.n);</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, o.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.n; ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.m; ++j)</span><br><span class="line">                    upd(ans.a[i][j], (ll) a[i][k] * o.a[k][j] % P);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                ans.a[i][j] = (ll) a[i][j] * o % P;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>+(<span class="keyword">const</span> mat &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; o.n &lt;&lt; &quot; &quot; &lt;&lt; o.m &lt;&lt; endl;</span></span><br><span class="line">        assert(n == o.n &amp;&amp; m == o.m);</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                ans.a[i][j] = a[i][j], upd(ans.a[i][j], o.a[i][j]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>-(<span class="keyword">const</span> mat &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        assert(n == o.n &amp;&amp; m == o.m);</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                ans.a[i][j] = a[i][j], upd(ans.a[i][j], P - o.a[i][j]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; zero, I, I2;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">unit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">ans</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ans.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gn = <span class="number">3</span>, ign = (P + <span class="number">1</span>) / gn;</span><br><span class="line"><span class="keyword">int</span> rev[N], W[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initW</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; N; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        W[<span class="number">1</span>][len] = mpow(gn, (P - <span class="number">1</span>) / len);</span><br><span class="line">        W[<span class="number">0</span>][len] = mpow(ign, (P - <span class="number">1</span>) / len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">glim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft_init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        rev[i] = rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span> | ((i&amp;<span class="number">1</span>) ? n &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(mat *f, <span class="keyword">int</span> n, <span class="keyword">int</span> flg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (rev[i] &lt; i) swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = len &gt;&gt; <span class="number">1</span>, wn = W[flg==<span class="number">1</span>][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += len)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, j = i; j &lt; i + k; j++, w = (ll) w * wn % P) &#123;</span><br><span class="line">                mat tmp = f[j + k] * w;</span><br><span class="line">                f[j + k] = f[j] - tmp;</span><br><span class="line">                f[j] = f[j] + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flg == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> inv = mpow(n, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            f[i] = f[i] * inv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_inv</span><span class="params">(<span class="keyword">const</span> mat *f, <span class="keyword">int</span> n, mat *g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; g[<span class="number">0</span>] = I; <span class="keyword">return</span>; &#125;</span><br><span class="line">    poly_inv(f, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, g);</span><br><span class="line">    <span class="keyword">static</span> mat tf[N];</span><br><span class="line">    <span class="keyword">int</span> lim = glim((n - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">        tf[i] = i &lt; n ? f[i] : zero;</span><br><span class="line">        g[i] = i &lt; n ? g[i] : zero;</span><br><span class="line">    &#125;</span><br><span class="line">    fft_init(lim);</span><br><span class="line">    fft(tf, lim, <span class="number">1</span>), fft(g, lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) g[i] = g[i] * (I2 - tf[i]*g[i]);</span><br><span class="line">    fft(g, lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; lim; ++i) g[i] = zero;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mat f[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, mv, Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    initW();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; Q &gt;&gt; mv;</span><br><span class="line">    zero = mat(n, n);</span><br><span class="line">    <span class="keyword">int</span> MLIM = glim(mv &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MLIM; ++i) ans[i] = f[i] = zero;</span><br><span class="line">    f[<span class="number">0</span>] = I = unit(n);</span><br><span class="line">    I2 = I * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        --u, --v;</span><br><span class="line">        upd(f[w].a[u][v], P - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    poly_inv(f, mv + <span class="number">1</span>, ans);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        --u, --v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[w].a[u][v] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>老博客链接</title>
    <url>/2020/08/11/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/</url>
    <content><![CDATA[<p>换blog辣~</p>
<a id="more"></a>
<p><a href="https://www.cnblogs.com/wxq1229">原来的博客</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
</search>
