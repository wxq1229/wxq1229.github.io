<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AtCoder Regular Contest 101</title>
    <url>/2020/08/12/AtCoder-Regular-Contest-101/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/arc101">Link</a></p>
<a id="more"></a>
<h2 id="C-Candles"><a href="#C-Candles" class="headerlink" title="C. Candles"></a>C. Candles</h2><p>被点燃蜡烛一定在一个区间内，枚举这个区间计算即可</p>
<p>复杂度$\mathcal{O}(N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15829782">评测链接</a></p>
<h2 id="D-Median-of-Medians"><a href="#D-Median-of-Medians" class="headerlink" title="D. Median of Medians"></a>D. Median of Medians</h2><p>对于一个长度为$N$的序列，它的median一定满足以下条件：</p>
<ul>
<li>序列中小于等于median的数（包括本身）的个数$\times 2 &gt; N$</li>
<li>median应为满足上面那个条件的最小的数</li>
</ul>
<p>二分，假设二分到的数为$x$，问题变为找有多少$m_{l,r}$，满足$m_{l,r} \le x$。</p>
<p>$m_{l,r} \le x$当且仅当$A_l…A_r$内小于等于$x$的数的数量<strong>超过</strong>一半（不能等于）</p>
<p>构造一个序列$d$，如果$A_i \le x$那么$d_i=1$，否则$d_i=-1$</p>
<p>那么$m$ 数量即为$d$上区间和大于$1$的区间个数</p>
<p>对$d$做前缀和得到$s$（$s_0=0$），问题变为有多少有序对$(i,j)$，满足</p>
<ul>
<li>$0 \le i &lt; j \le N$ 且 $s_j&gt;s_i$</li>
</ul>
<p>树状数组计算顺序对的个数即可</p>
<p>复杂度$\mathcal{O}(N \log^2N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15831453">评测链接</a></p>
<h2 id="E-Ribbons-on-Tree"><a href="#E-Ribbons-on-Tree" class="headerlink" title="E. Ribbons on Tree"></a>E. Ribbons on Tree</h2><p>要求所有边都被覆盖到，不妨考虑容斥</p>
<p>定义$f(S)$表示满足下面条件的方案数：</p>
<ul>
<li>对于集合$S$中的边，一定不能被覆盖到，其他点随意两两匹配的方案数</li>
</ul>
<p>那么最后的答案即为$\sum_{S \subseteq E} (-1)^{\mid S\mid}f(S)$</p>
<p>如果限制了一条边不能被覆盖，那么就可以把这条边删去，这样会把树分成若干个连通块</p>
<p>那么$f(S)$就是每个连通块中点两两匹配的方案数的乘积</p>
<p>定义$g(N)$表示$N$个点两两匹配的方案数，那么有</p>
<script type="math/tex; mode=display">
g(N) = \begin{cases}
(N-1)(N-3)\cdots 1 \quad (2 \mid N) \\
0 \quad\quad\quad\quad\quad\quad\quad\quad \ \ \ \ \  (2 \not\mid N)
\end{cases}</script><p>即第$1$个点有$N-1$个点可供匹配，去除两个后剩下来的第二个待匹配点有$N-3$个点共匹配</p>
<p>考虑树形DP出上面那个式子的值</p>
<p>定义$dp(u,i)$表示在点$u$的子树中，点$u$所在连通块大小为$i$时对答案的贡献总和（不算$i$所在连通块的贡献）</p>
<p>枚举儿子$v$讨论割或者不割$(u,v)$这条边的贡献。如果割，那么要乘上一个$-1$的常数。</p>
<p>类似树上背包那样转移即可</p>
<p>复杂度$\mathcal{O}(N^2)$，<a href="https://atcoder.jp/contests/arc101/submissions/15659672">评测链接</a></p>
<h2 id="F-Robots-and-Exits"><a href="#F-Robots-and-Exits" class="headerlink" title="F. Robots and Exits"></a>F. Robots and Exits</h2><p>一个机器人只能从在他左边或右边最近的出口出去</p>
<p>同时删去在第一个出口左边、在最后一个出口右边和原来就在出口上的机器人不会影响答案（因为他们能匹配的出口就一个）</p>
<p>对于第$i$个机器人，令$x_i$表示它到它左边离它最近的出口的距离，$y_i$表示它到它右边离它最近的出口的距离</p>
<p>把这个点$(x_i,y_i)$放到直角坐标系下</p>
<p>在一个时刻，影响一个机器人是否消失的条件只有</p>
<ul>
<li>向左走走到最远的位置到原来位置的距离</li>
<li>向右走走到最远的位置到原来位置的距离</li>
</ul>
<p>不妨用一个二元组$(l,r)$来表示当前的状态</p>
<p>对于还未消失的机器人$i$，如果$l=x_i$或者$r=y_i$那么这个机器人就一定会在当前时刻消失，分别表示从左边/右边的出口出去</p>
<p>我们可以通过不断向左或向右移动，使得$(l,r) \rightarrow (l+1,r)$或$(l,r+1)$。</p>
<p>考虑一个DP，令$dp_i$表示最后一个从右边出去的机器人为$i$时的匹配方案数</p>
<p>有转移$dp_i = 1+\sum\limits_{x_j&lt;x_i,y_j&lt;y_i} dp_j$</p>
<p>即枚举上一个从右边出去的$j$（且$i$在这段时间内没有消失），然后一直使$l+1$让中间那段机器人从左边走，然后再向右让$i$从右边走掉。加$1$表示$i$是第一个从右边消失的机器人</p>
<p>然后答案即$1+\sum_{i=1}^N dp_i$（加$1$表示所有机器人都从左边走）</p>
<p>按照$x$为第一关键字（从小到大）$y$为第二关键字（<strong>从大到小</strong>）排序后用树状数组维护$y$的限制转移即可</p>
<p>复杂度$\mathcal{O}(N \log N)$，<a href="https://atcoder.jp/contests/arc101/submissions/15845816">评测链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Dwango Programming Contest 6th</title>
    <url>/2020/08/15/Dwango-Programming-Contest-6th/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/dwacon6th-prelims">Link</a></p>
<a id="more"></a>
<h2 id="A-Falling-Asleep"><a href="#A-Falling-Asleep" class="headerlink" title="A. Falling Asleep"></a>A. Falling Asleep</h2><p>难/kk，<a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/15883987">评测链接</a></p>
<h2 id="B-Fusing-Slimes"><a href="#B-Fusing-Slimes" class="headerlink" title="B. Fusing Slimes"></a>B. Fusing Slimes</h2><p>由期望的线性性可以把$N-1$个间隙分开来考虑，设$f_i$表示左边有$i$只slime的一段区间期望被经过多少次</p>
<p>那么答案就是$\sum_{i=1}^{N-1} (x_{i+1}-x_i)f_i$</p>
<p>考虑计算$f_i$，首先第一次如果就抽到线段左边第一个点的话那么经过次数会加1，不然就变成$i-1$个slime的情况</p>
<p>因此$f_i=\frac{1}{i}+f_{i-1}$，递推即可</p>
<p>复杂度$\mathcal{O}(N)$，<a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/15885372">评测链接</a></p>
<h2 id="C-Cookie-Distribution"><a href="#C-Cookie-Distribution" class="headerlink" title="C. Cookie Distribution"></a>C. Cookie Distribution</h2><p>最后乘上组合数相当于直接统计所有分配方案下小朋友们的愉悦度总和</p>
<p>看起来没啥思路，注意到最后那个乘法，$c_i$相当于在小朋友$i$获得的$c_i$块饼干中抢走一块的方案数，最后从每个小朋友手中抢走一块饼干</p>
<p>考虑DP，令$dp_{i,j}$表示分配完前$i$天，有$j$个小朋友已经被抢走一个饼干的方案数</p>
<p>枚举第$i+1$天被抢走刚分配到的饼干的小朋友的数量转移即可</p>
<p>复杂度$\mathcal{O}(KN^2)$，<a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/15885734">评测链接</a></p>
<h2 id="D-Arrangement"><a href="#D-Arrangement" class="headerlink" title="D. Arrangement"></a>D. Arrangement</h2><p><del>搜，都可以搜</del></p>
<p>相当于找补图中字典序最小的哈密顿路径</p>
<p>这$N \le 10^5$完全没想法啊</p>
<p>但是补图比较稠密，所以随便搜出一条路径的概率还是挺大的，考虑乱搞</p>
<p>直接爆搜，但枝还是要剪的，不然一个$-1$就起飞了</p>
<ul>
<li><p>考虑搜出的当前路经中最后一个点$u$，如果$a_u$不在搜到的路径上，且$a_u$不能放在所有不在搜到路径上的点的右边那么当前状态显然不可能搜出一条合法的路径</p>
</li>
<li><p>另外可以维护一下下一个点的最小值</p>
</li>
</ul>
<p>加了这两个剪枝过后跑的飞快/cy</p>
<p>复杂度$\mathcal{O}(?)$，<a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/15886644">评测链接</a></p>
<h2 id="E-Span-Covering"><a href="#E-Span-Covering" class="headerlink" title="E. Span Covering"></a>E. Span Covering</h2><p>限制所有整点都要被覆盖到，考虑容斥，枚举$k$个未被覆盖的点$p_1,p_2,\cdots,p_k$，会把$[0,X)$从左往右依次分成$[0,p_1),[p1+1,p_2),\cdots ,[p_{k-1}+1,p_k),[p_k+1,X)$这$k+1$个小区间</p>
<p>设这些区间的长度分别是$S_1,S_2,\cdots,S_{k+1}$（$S_i \ge 0$）</p>
<p>那么第$i$个sheet，他就有$\sum\limits_{S_j+1 \ge L_i} S_j-L_i+1$种摆放方式，所以这种情况下总共有$\prod_{i=1}^N \sum\limits_{S_j+1 \ge L_i} S_j-L_i+1$个不同方案</p>
<p>将所有情况下的摆放方案乘上一个容斥系数$(-1)^k$求和即可</p>
<p>考虑给定$k$如何求所有满足限制的方案的和</p>
<p>首先由于强制不能被覆盖的点$p$可能会相邻或者在左右边界上，这些都会使$S_i=0$，也就是说我们并不知道$S$的和，不是很方便算方案数</p>
<p>不妨让所有$S$加$1$，这时候显然有$\sum S_j=X+1$，让$X$也加$1$好了</p>
<p>于是柿子变成枚举所有的$\sum_{j=1}^{k+1} S_j=X(S_j \ge 1)$，对$\prod_{i=1}^N \sum\limits_{S_j \ge L_i} S_j-L_i$求和</p>
<p>考虑DP，为了方便我们强制$S$从大到小排列只要在最后乘上可重集的排列数就好了</p>
<p>令$dp_{l,c,x}$表示$k=c-1$，$S_1 \ge S_2 \ge \cdots S_{c} &gt; l$，$\sum S_j=x$时上面柿子的和（同时限制柿子中的$L_i &gt; l$）</p>
<p>在用$dp_{l}$更新$dp_{l-1}$的时候先算前面几个sheet所代表的因式的贡献再乘上$L_i=l$这些sheet所代表的因式的贡献也就是$x-cL_i$即可</p>
<p>复杂度$\mathcal{O}(X^3)$左右，不会算/kk，<a href="https://atcoder.jp/contests/dwacon6th-prelims/submissions/15904207">评测链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>NOMURA Programming Competition 2020</title>
    <url>/2020/08/20/NOMURA-Programming-Competition-2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/nomura2020">Link</a></p>
<a id="more"></a>
<h2 id="A-Study-Scheduling"><a href="#A-Study-Scheduling" class="headerlink" title="A. Study Scheduling"></a>A. Study Scheduling</h2><p>难/kk，<a href="https://atcoder.jp/contests/nomura2020/submissions/16004681">评测链接</a></p>
<h2 id="B-Postdocs"><a href="#B-Postdocs" class="headerlink" title="B. Postdocs"></a>B. Postdocs</h2><p>填$\text{D}$至少使答案加$1$，一定不会劣与$\text{P}$，于是全部填$\text{D}$即可</p>
<p>复杂度$\mathcal{O}(|T|)$，<a href="https://atcoder.jp/contests/nomura2020/submissions/16004703">评测链接</a></p>
<h2 id="C-Folia"><a href="#C-Folia" class="headerlink" title="C. Folia"></a>C. Folia</h2><p>第$N$层一定只有$A_N$个点</p>
<p>如果第$i$层有$C_i$个节点，那么第$i-1$层最少有$\lceil C_i /2\rceil+A_{i-1}$（尽量两个节点共用一个爸爸），最多有$C_i+A_{i-1}$个节点（一个节点一个父亲）</p>
<p>于是可以递推出第$i$层节点个数的上界以及下界，判断无解就看第$0$层是否能有$1$个节点</p>
<p>然后贪心安排$1$到$N$层的节点个数即可，另外注意$N=0$时的一些特判</p>
<p>复杂度$\mathcal{O}(N)$，<a href="https://atcoder.jp/contests/nomura2020/submissions/16005201">评测链接</a></p>
<h2 id="D-Urban-Planning"><a href="#D-Urban-Planning" class="headerlink" title="D. Urban Planning"></a>D. Urban Planning</h2><p>考虑知道所有$P_i$过后如何计算最小需要的边数</p>
<p>对于一个$i$，连一条双向边$(i,P_i)$，那么所形成的的图一定是一个基环树森林，对于每棵基环树，可以省去一条在环上的边，于是最小边数就是$N-C$（$C$为环的个数）</p>
<p>那么先对于所有已知的$P_i$连一条$(i,P_i)$的双向边，所形成的图一定是几棵树加一些基环树，每棵树中一定有一个未知$P_i$的节点$i$，以它们为根，形成了$K$棵树$T_1,T_2,\cdots,T_K$</p>
<p>我们需要计算在所有情况下$C$的总和，其余已知基环树的贡献我们可以直接算出来</p>
<p>在树中选择若干个出来在它们之间连边会形成一个环，设选出来$M$棵树，为$T’_1,T’_2,\cdots,T’_M$，那么这些树的贡献就是$(N-1)^{K-M-1}(M-1)!\prod\limits_{i=1}^{M} |T’_i|$（$|T|$表示树$T$的大小），即其他点的安排方案数$\times$圆排列的个数$\times$ 形成环的连边方案数</p>
<p>DP出$M=1 \cdots K$时$\prod$的和，注意特判$M=1$的时候$\prod$里面是$|T’ |-1$</p>
<p>实现的时候写的是单向边，但判环什么的问题不大</p>
<p>复杂度$\mathcal{O}(N^2)$，<a href="https://atcoder.jp/contests/nomura2020/submissions/16009585">评测链接</a></p>
<h2 id="E-Binary-Programming"><a href="#E-Binary-Programming" class="headerlink" title="E. Binary Programming"></a>E. Binary Programming</h2><p>转化，考虑把操作倒过来</p>
<ul>
<li>将所有奇数位上数的和累加到答案上</li>
<li>删除指定的一个位置</li>
</ul>
<p>先删除$\text{0}$一定不会亏，于是在所有$\text{0}$被删除后再删$\text{1}$，我们只要决定如何删$\text{0}$能使贡献最大就好了</p>
<p>注意到两个连续的$\text{1}$位置一定是一奇一偶，所以在一次删除后这两个位置会贡献且仅会贡献$1$，于是可以忽略这两个位置，后面位置的奇偶性不会发生改变</p>
<p>那么我们只要考虑形如$\text{00…0100…0100…01…}$这样的串</p>
<p>考虑一个位置上的$\text{1}$对答案的贡献最大是多少，设他前面有$A$个$0$，后面有$B$个$0$，只要保证删除后面数的时候它都在奇数位上贡献就可以达到最大，那么对于奇数位上的$\text{1}$贡献最大为$1+\lfloor A/2\rfloor+B$，对于偶数位上的，贡献最大为$\lceil A/2 \rceil+B$</p>
<p>每个位置贡献的最大值都能被达到，我们可以构造出如下方案</p>
<ul>
<li>先删除第一段所有的$\text{0}$，再把后面从左到右的每段$\text{0}$依次删到每段只剩下一个（这样可以保证在删除某个$\text{1}$后面的$\text{0}$的时候它在奇数位上），然后把剩下的$\text{0}$全部删掉</li>
</ul>
<p>最后把剩下来全是$\text{1}$的串的贡献加上即可</p>
<p>复杂度$\mathcal{O}(|T|)$，<a href="https://atcoder.jp/contests/nomura2020/submissions/16045181">评测链接</a></p>
<h2 id="F-Sorting-Game"><a href="#F-Sorting-Game" class="headerlink" title="F. Sorting Game"></a>F. Sorting Game</h2><p>考虑什么样的序列才能完成排序，一个必要条件是</p>
<ul>
<li>对于一个序列$A$中的两个位置$i,j$，如果 $i &lt; j$ 且 $A_i &gt; A_j$，就应当满足 $A_i,A_j$ 在二进制下有且仅有 $1$ 位不同（因为这两个位置上的数一定会在某次操作被交换）</li>
</ul>
<p>如果满足上面这个条件，显然能构造出排序的方法：让最小的数一路往前与比他大的数交换，这样它一定能到最左边，第二小的数一路往前与比他大的数交换，这样它最后会到第二个位置，以此类推，最终一定能完成排序</p>
<p>所以一个序列合法当且仅当它满足这个条件</p>
<p>任意选择几个二进制位变成$0$就相当于删除那一位，因此对于原序列中的一对位置$i,j$（$i &lt; j$），如果在删去若干数位后有 $A_i &gt; A_j$ 那么此时 $A_i$ 与 $A_j$ 要满足二进制下有且仅有 $1$ 位不同</p>
<p>考虑两个数$A,B$，在二进制下从高位往低位看，设$A$当前数位上的数为$x$，$B$当前数位上的数上为$y$</p>
<ul>
<li><p>如果$x=0,y=0$或$x=1,y=1$显然当前位删不删除没有什么区别，继续往下看</p>
</li>
<li><p>如果$x=0,y=1$，最坏情况下该位会被删除（不然此时$A$一定小于$B$），依然继续扫描</p>
</li>
<li><p>如果$x=1,y=0$，在这位不被删除的情况下对方就能在操作后使得$A&gt;B$，那么后面的若干位就一定要<strong>全部相等</strong>，如果全部相等那么判定合法，否则整个序列就不合法</p>
</li>
</ul>
<p>所以如果序列$A$合法，对于所有$i,j$（$i&lt;j$），对$A_i,A_j$做上述扫描后都应该合法</p>
<p>DP，从低到高安排每一个数位，令$dp_{i,j}$表示$N=i,M=j$时候的答案</p>
<p>考虑$j$个数每个数二进制下最高位从左到右排开来会长什么样，注意到前缀$0$与后缀$1$并不会有什么影响，可以先将前缀$0$与后缀$1$删去</p>
<ul>
<li>如果删下来是空串，即原来最高位排开来长这样$\text{00…011…1}$，那么不管后面数位如何都一定满足条件，于是$dp_{i,j} \leftarrow (j+1)\times dp_{i-1,j}$</li>
<li>若删下来不是空串，原来就应该长成这样$\text{00…01??…?011…1}$，此时第一个$1$与最后一个$0$所在的那两个数后面几位一定要全部相等，而中间的$\text{?}$位置上的数一定会和前面的$1$或后面的$0$发生冲突，即这一段所有数后面的数位都应该全部相等，不妨把$\text{1??…?0}$缩成一个数，于是串变成这样$\text{00..0X11..1}$，枚举缩水后串的长度转移即可</li>
</ul>
<p>于是$dp_{i,j} = dp_{i-1,j} \times (j+1) + \sum\limits_{k=1}^{j-1} 2^{j-k-1} \times k \times dp_{i-1,k}$，用前缀和优化转移即可</p>
<p>复杂度$\mathcal{O}(NM)$，<a href="https://atcoder.jp/contests/nomura2020/submissions/16023250">评测链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Tokio Marine &amp; Nichido Fire Insurance Programming Contest 2020</title>
    <url>/2020/08/11/Tokio-Marine-Nichido-Fire-Insurance-Programming-Contest-2020/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/tokiomarine2020">Link</a></p>
<a id="more"></a>
<h2 id="A-Nickname"><a href="#A-Nickname" class="headerlink" title="A. Nickname"></a>A. Nickname</h2><p>难/kk，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15709689">评测链接</a></p>
<h2 id="B-Tag"><a href="#B-Tag" class="headerlink" title="B. Tag"></a>B. Tag</h2><p>难/kk， <a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15709850">评测链接</a></p>
<h2 id="C-Lamps"><a href="#C-Lamps" class="headerlink" title="C. Lamps"></a>C. Lamps</h2><p>发现有效的操作轮数不是很多，模拟到所有$A_i=N$即可，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15710108">评测链接</a></p>
<h2 id="D-Knapsack-Queries-on-a-tree"><a href="#D-Knapsack-Queries-on-a-tree" class="headerlink" title="D. Knapsack Queries on a tree"></a>D. Knapsack Queries on a tree</h2><p><del>有幸遇到了一道校内膜你赛的题</del></p>
<p>一次询问只会和当前点到根路径上的点有关，同时注意到前$\frac{1}{2}$层的节点总数在$\sqrt{N}$级别，后面的层数很少但节点却很多。</p>
<p>分块，DP预处理出前$1…S$个点在$L=1…10^5$时的答案，对于后面的点$2^n$暴力即可。</p>
<p>取$S=\sqrt{N}$，询问总复杂度$O(Q\sqrt N)$，<a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15710437">评测链接</a></p>
<h2 id="E-O-rand"><a href="#E-O-rand" class="headerlink" title="E. O(rand)"></a>E. O(rand)</h2><p>注意到一点，考虑$S$和$T$二进制下从右起第$i$位，分四种情况</p>
<ul>
<li><p>$S$当前位为$1$，$T$当前位为$0$，原地爆炸，$Ans=0$</p>
</li>
<li><p>$S$当前位为1，$T$当前位为$1$，那么就一定不能选这位为$0$的数</p>
</li>
<li><p>$S$当前位为$0$，$T$当前位为$0$，那么就一定不能选这位为$1$的数</p>
</li>
<li><p>$S$当前位为$0$，$T$当前位为$1$，既要选这一位为$1$的又要选这一位为$0$的</p>
</li>
</ul>
<p>判定无解或去除一定不会被选的数后问题变为$S=0$，$T=2^k-1$。</p>
<p>考虑容斥，令$f(U)$表示满足下面这个条件的方案的数量：</p>
<ul>
<li>若集合$U$中不包含元素$i$，那么对这一位没有要求</li>
<li>若集合$U$中包含元素$i$，那么选出的所有数$or$起来这一位不是$1$，或者$and$起来不为$0$</li>
</ul>
<p>答案即为$\sum_U (-1)^{\mid U\mid} f(U)$</p>
<p>考虑怎么计算$f(U)$，由于不关心$U$中不包含的二进制位，所以将所有$A_i$与上$U$，然后再计数。</p>
<p>这样过后$A_i$就只能和自己相同的$A_j$分在一组。</p>
<p>预处理出组合数前缀和，开个桶算下即可。</p>
<p><a href="https://atcoder.jp/contests/tokiomarine2020/submissions/15722626">评测链接</a></p>
<h2 id="F-Triangles"><a href="#F-Triangles" class="headerlink" title="F. Triangles"></a>F. Triangles</h2><p>不会，咕咕咕（</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>UOJ551 【UNR #4】校园闲逛</title>
    <url>/2020/08/13/UOJ551-%E3%80%90UNR-4%E3%80%91%E6%A0%A1%E5%9B%AD%E9%97%B2%E9%80%9B/</url>
    <content><![CDATA[<p><a href="http://uoj.ac/problem/551">Link</a></p>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑把邻接矩阵作为多项式的系数构造一个多项式</p>
<script type="math/tex; mode=display">
F(x) = \sum\limits_{i=1}^{maxv} A_ix^i</script><p>其中$A_i$表示仅由权值为$i$的边构成的图的邻接矩阵</p>
<p>枚举经过了多少条边，答案的生成函数就是</p>
<script type="math/tex; mode=display">
Ans(x) = 1+F(x)+F^2(x)+F^3(x) +\cdots = \frac{1}{1-F(x)}</script><p>（$Ans(x)$ $i$次项的系数是个矩阵，第$u$行第$v$列就表示$u \rightarrow v$，权值和为$i$的路径个数）</p>
<p>以上多项式的系数都是矩阵，但是显然不影响fft。</p>
<p>那怎么求逆呢？</p>
<p>注意到整数和矩阵有一个的区别就是矩阵乘法并不满足交换律，这里重新推下多项式求逆避免一些奇怪的结果</p>
<p>首先假设要对$F(x)$在$\bmod x^n$意义下求逆$G(x)$，即</p>
<script type="math/tex; mode=display">
F(x)G(x) \equiv I \pmod{x^n}</script><p>同时我们已经知道了$F(x)H(x) \equiv I \pmod{x^{\lceil \frac{n}{2}\rceil}}$</p>
<p>之前多项式求逆的时候有一种做法是把这两个式子作差，然后再提个$F(x)$得到</p>
<script type="math/tex; mode=display">
F(x)(G(x)-H(x)) \equiv 0 \pmod{x^{\lceil \frac{n}{2}\rceil}}</script><script type="math/tex; mode=display">
G(x)-H(x) \equiv 0 \pmod{x^{\lceil \frac{n}{2} \rceil}}</script><p>然后平方后把模变成$x^n$，用到了二项式定理，但这种多项式并不能这样展开，因为矩阵的乘法并不满足交换律从而它的卷积也不满足交换律，然后就并不能像那样用归纳法证明二项式定理</p>
<p><del>但好像这不足以说明它一定是错的，然而这样确实不能过样例</del></p>
<p>所以我们换个姿势：</p>
<script type="math/tex; mode=display">
F(x)H(x) - I \equiv 0 \pmod{x^{\lceil\frac{n}{2}\rceil}}</script><p>注意到这时候是能二项式定理的，因为$IA=AI$，满足交换律，开心（但要注意乘法的顺序</p>
<script type="math/tex; mode=display">
F(x)H(x)F(x)H(x) - 2F(x)H(x) + I \equiv 0 \pmod {x^n}</script><script type="math/tex; mode=display">
F(x)(H(x)F(x)H(x)-2H(x)) \equiv -I \pmod{x^n}</script><script type="math/tex; mode=display">
H(x)F(x)H(x)-2H(x) \equiv -F^{-1}(x) \pmod{x^n}</script><script type="math/tex; mode=display">
F^{-1}(x) \equiv 2H(x)-H(x)F(x)H(x) \pmod{x^n}</script><p>右边也就是那个$G(x)$</p>
<p>这样对$1-F(x)$求逆即可</p>
<p>复杂度$\mathcal{O}(n^3v \log v)$ <del>自带巨大常数</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>, P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = (ll) a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ll) ans * a % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x = x + y - P; x += x &gt;&gt; <span class="number">31</span> &amp; P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>][<span class="number">8</span>], n, m;</span><br><span class="line"></span><br><span class="line">    mat(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>) &#123;</span><br><span class="line">        n = r, m = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) a[i][j] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="keyword">const</span> mat &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; o.n &lt;&lt; &quot; &quot; &lt;&lt; o.m &lt;&lt; endl;</span></span><br><span class="line">        assert(m == o.n);</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, o.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.n; ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.m; ++j)</span><br><span class="line">                    upd(ans.a[i][j], (ll) a[i][k] * o.a[k][j] % P);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                ans.a[i][j] = (ll) a[i][j] * o % P;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>+(<span class="keyword">const</span> mat &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; o.n &lt;&lt; &quot; &quot; &lt;&lt; o.m &lt;&lt; endl;</span></span><br><span class="line">        assert(n == o.n &amp;&amp; m == o.m);</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                ans.a[i][j] = a[i][j], upd(ans.a[i][j], o.a[i][j]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mat <span class="keyword">operator</span>-(<span class="keyword">const</span> mat &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        assert(n == o.n &amp;&amp; m == o.m);</span><br><span class="line">        <span class="function">mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                ans.a[i][j] = a[i][j], upd(ans.a[i][j], P - o.a[i][j]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; zero, I, I2;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">unit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">ans</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ans.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gn = <span class="number">3</span>, ign = (P + <span class="number">1</span>) / gn;</span><br><span class="line"><span class="keyword">int</span> rev[N], W[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initW</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; N; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        W[<span class="number">1</span>][len] = mpow(gn, (P - <span class="number">1</span>) / len);</span><br><span class="line">        W[<span class="number">0</span>][len] = mpow(ign, (P - <span class="number">1</span>) / len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">glim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> lim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft_init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        rev[i] = rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span> | ((i&amp;<span class="number">1</span>) ? n &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(mat *f, <span class="keyword">int</span> n, <span class="keyword">int</span> flg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (rev[i] &lt; i) swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = len &gt;&gt; <span class="number">1</span>, wn = W[flg==<span class="number">1</span>][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += len)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, j = i; j &lt; i + k; j++, w = (ll) w * wn % P) &#123;</span><br><span class="line">                mat tmp = f[j + k] * w;</span><br><span class="line">                f[j + k] = f[j] - tmp;</span><br><span class="line">                f[j] = f[j] + tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flg == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> inv = mpow(n, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            f[i] = f[i] * inv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poly_inv</span><span class="params">(<span class="keyword">const</span> mat *f, <span class="keyword">int</span> n, mat *g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; g[<span class="number">0</span>] = I; <span class="keyword">return</span>; &#125;</span><br><span class="line">    poly_inv(f, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, g);</span><br><span class="line">    <span class="keyword">static</span> mat tf[N];</span><br><span class="line">    <span class="keyword">int</span> lim = glim((n - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">        tf[i] = i &lt; n ? f[i] : zero;</span><br><span class="line">        g[i] = i &lt; n ? g[i] : zero;</span><br><span class="line">    &#125;</span><br><span class="line">    fft_init(lim);</span><br><span class="line">    fft(tf, lim, <span class="number">1</span>), fft(g, lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) g[i] = g[i] * (I2 - tf[i]*g[i]);</span><br><span class="line">    fft(g, lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; lim; ++i) g[i] = zero;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mat f[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> n, m, mv, Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    initW();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; Q &gt;&gt; mv;</span><br><span class="line">    zero = mat(n, n);</span><br><span class="line">    <span class="keyword">int</span> MLIM = glim(mv &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MLIM; ++i) ans[i] = f[i] = zero;</span><br><span class="line">    f[<span class="number">0</span>] = I = unit(n);</span><br><span class="line">    I2 = I * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        --u, --v;</span><br><span class="line">        upd(f[w].a[u][v], P - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    poly_inv(f, mv + <span class="number">1</span>, ans);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        --u, --v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[w].a[u][v] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>老博客链接</title>
    <url>/2020/08/11/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/</url>
    <content><![CDATA[<p>换blog辣~</p>
<a id="more"></a>
<p><a href="https://www.cnblogs.com/wxq1229">原来的博客</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 092</title>
    <url>/2020/08/27/AtCoder-Regular-Contest-092/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/arc092">Link</a></p>
<a id="more"></a>
<h2 id="C-2D-Plane-2N-Points"><a href="#C-2D-Plane-2N-Points" class="headerlink" title="C. 2D Plane 2N Points"></a>C. 2D Plane 2N Points</h2><p>$N \le 100$，二分图匹配裸题，好像还有个妙妙贪心</p>
<p>复杂度$\mathcal{O}(N^3)$，<a href="https://atcoder.jp/contests/arc092/submissions/16177277">评测链接</a></p>
<h2 id="D-Two-Sequences"><a href="#D-Two-Sequences" class="headerlink" title="D. Two Sequences"></a>D. Two Sequences</h2><p>考虑计算答案二进制下的第$k$位，问题变为统计有多少$(i,j)$使得$a_i+b_j$二进制下第$k$位为$1$</p>
<p>首先只保留$a_i,b_i$二进制下后$k$位（即对$2^{k+1}$取模），二进制下第$k$位为$1$相当于$2^{k} \le (a_i+b_j) \bmod 2^{k+1}$，分类讨论</p>
<ul>
<li><script type="math/tex">\begin{cases} a_i+b_j < 2^{k+1} \\ a_i+b_j \ge 2^{k} \end{cases}</script>，可以得到$2^{k}-a_i \le b_j &lt; 2^{k+1}-a_i$</li>
<li><script type="math/tex">\begin{cases} a_i+b_j \ge 2^{k+1} \\ a_i + b_j - 2^{k+1} \ge 2^{k}\end{cases}</script>，可以得到$b_j \ge 2^{k+1}+2^{k}-a_i$</li>
</ul>
<p>将$b$排序枚举$a_i$二分即可</p>
<p>复杂度$\mathcal{O}(N \log N \log V)$，<a href="https://atcoder.jp/contests/arc092/submissions/16178438">评测链接</a></p>
<h2 id="E-Both-Sides-Merger"><a href="#E-Both-Sides-Merger" class="headerlink" title="E. Both Sides Merger"></a>E. Both Sides Merger</h2><p>最后剩下的数一定是原序列里若干数的和，且这些数在原序列里下标的奇偶性要相同</p>
<p>于是答案就是奇数位上正数的和与偶数位上正数的和的最大值</p>
<p>考虑构造，假设选出来的下标为$p_{1},p_{2},\cdots ,p_M$，先把左右边界的数全部删掉再从左往右合并</p>
<p>对于两个相邻的位置$p_i,p_{i+1}$， 一直删去两个位置的中点即可（由于两个位置的奇偶性相同，所以一定能删干净）</p>
<p>注意特判所有数都小于等于$0$的情况</p>
<p>复杂度$\mathcal{O}(N)$，<a href="https://atcoder.jp/contests/arc092/submissions/16225683">评测链接</a></p>
<h2 id="F-Two-Faced-Edges"><a href="#F-Two-Faced-Edges" class="headerlink" title="F. Two Faced Edges"></a>F. Two Faced Edges</h2><p>翻转一条边，把删除和加入分开来看，对于翻转边$u \rightarrow v$</p>
<ul>
<li><p>删除边$u \rightarrow v$，如果原来$v$能到达$u$，且$u$不能不通过$u \rightarrow v$这条边到达$v$，那么强联通分量的个数将增加$1$</p>
</li>
<li><p>加入边$v \rightarrow u$，如果原来$u$能不通过$u \rightarrow v$这条边到达$v$，且原来$v$不能到达$u$，那么强联通分量的个数将减少$1$</p>
</li>
</ul>
<p>只要能判定上面这两个东西就能知道翻转一条边后强联通分量的个数是否会改变了</p>
<p>我们需要回答两种问题</p>
<ul>
<li>原来$u$能否到达$v$</li>
<li>原来$u$能否不通过$u \rightarrow v$这条边到达$v$</li>
</ul>
<p>对于第一个问题遍历一遍就好，考虑第二个问题</p>
<p>枚举$u$以及它的出边$u \rightarrow v_1, u \rightarrow v_2, \cdots, u \rightarrow v_M$</p>
<p>对于一条边$u \rightarrow v_i$，如果$u$到达$v_i$能不经过它，那么经过$u \rightarrow v_1, u \rightarrow v_2, \cdots, u \rightarrow v_{i-1}$或$u \rightarrow v_{i+1}, u \rightarrow v_{i+2}, \cdots, u \rightarrow v_M$这些边就一定能到达$v_i$</p>
<p>先按$v_1,v_2,\cdots v_M$的顺序进行遍历，对每个点给它标记上第一次到达这个点经过的是那条边</p>
<p>再按$v_M,v_{M-1},\cdots,v_{1}$遍历，同上对每个点做标记</p>
<p>于是对于一条边$u \rightarrow v_i$，$u$到达$v_i$能不经过它，当且仅当两次遍历下来$v_i$的标记一样（这时候一定都是$i$）</p>
<p>复杂度$\mathcal{O}(NM)$，<a href="https://atcoder.jp/contests/arc092/submissions/16245218">评测链接</a></p>
]]></content>
      <categories>
        <category>AtCoder</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 85</title>
    <url>/2020/08/30/Educational-Codeforces-Round-85/</url>
    <content><![CDATA[<p><a href="https://codeforces.ml/contest/1334">Link</a></p>
<a id="more"></a>
<h2 id="A-Level-Statistics"><a href="#A-Level-Statistics" class="headerlink" title="A. Level Statistics"></a>A. Level Statistics</h2><p>阅读理解题…，<a href="https://paste.ubuntu.com/p/PcsRp5Fqk2/">代码链接</a></p>
<h2 id="B-Middle-Class"><a href="#B-Middle-Class" class="headerlink" title="B. Middle Class"></a>B. Middle Class</h2><p>贪心，尽量选有钱的人平均分配，<a href="https://paste.ubuntu.com/p/xbxRKF58M3/">代码链接</a></p>
<h2 id="C-Circle-of-Monsters"><a href="#C-Circle-of-Monsters" class="headerlink" title="C. Circle of Monsters"></a>C. Circle of Monsters</h2><p>怪兽一定是按顺序打过去的，枚举第一个打的是那个顺时针打过去就好了</p>
<p>前缀和什么的算一下就好了，<a href="https://paste.ubuntu.com/p/BjdvYgpJdh/">代码链接</a></p>
<h2 id="D-Minimum-Euler-Cycle"><a href="#D-Minimum-Euler-Cycle" class="headerlink" title="D. Minimum Euler Cycle"></a>D. Minimum Euler Cycle</h2><p>打 表 找 规 律</p>
<p>可以手玩较小的$n$</p>
<p>当$n=3$时，字典序最小的欧拉回路长这样<code>1 2 1 3 2 3 1</code></p>
<p>当$n=4$时是<code>1 2 1 3 1 4 2 3 2 4 3 4 1</code></p>
<p>已经能看出规律了，<code>1 2 1 3 1 4</code> | <code>2 3 2 4</code> | <code>3 4</code>| <code>1</code></p>
<p>推测一下$n=5$时是<code>1 2 1 3 1 4 1 5 2 3 2 4 2 5 3 4 3 5 4 5 1</code>，画一下发现好像对了</p>
<p><a href="https://paste.ubuntu.com/p/TcsFnDzKqD/">代码链接</a></p>
<h2 id="E-Divisor-Paths"><a href="#E-Divisor-Paths" class="headerlink" title="E. Divisor Paths"></a>E. Divisor Paths</h2><p>结论题</p>
<p>对于点$u$，把它质因数分解后得到$u=\prod_{i=1}^k p_i^{a_i}$，那么每走一条边就相当于把某个$a_i$加一或减一</p>
<p>对于$(u,v)$这条边（$v \mid u$），他的边权显然是$d(u)-d(v)$，同时可以知道如果$v \mid u$那么$u$到$v$的最短路一定是$d(u)-d(v)$</p>
<p>那么对于$u,v$的最短路，一种情况是$u \rightarrow \operatorname{lcm}(u,v) \rightarrow v$，另一种是$u \rightarrow \gcd(u,v) \rightarrow v$</p>
<p>即先加后减或先减后加</p>
<p>讨论一下，设$d(u)=xy,d(\operatorname{lcm}(u,v))=(x+p)y,d(\gcd(u,v))=x(y-q),d(v)=(x+p)(y-q)$</p>
<ul>
<li><p>$u \rightarrow \operatorname{lcm}(u,v) \rightarrow v$</p>
<p>长度为$py+qx+pq$</p>
</li>
<li><p>$u \rightarrow \gcd(u,v) \rightarrow v$</p>
<p>长度为$qx+py-pq$</p>
</li>
</ul>
<p>显然走$\gcd$要比$\operatorname{lcm}$优</p>
<p>剩下的就是计数，变成$v \mid u$的情况，由于指数是一个一个减一的，所以是一个可重集全排列</p>
<p>然后就做完了，<a href="https://paste.ubuntu.com/p/sk34jFYZQw/">代码链接</a></p>
<h2 id="F-Strange-Function"><a href="#F-Strange-Function" class="headerlink" title="F. Strange Function"></a>F. Strange Function</h2><p>考虑一个看起来就不太行的$dp$，令$dp_{i,j}$表示$a_{1…i}$在删除若干数过后使得$f([a_1,a_2,\cdots,a_i])=[b_1,b_2,\cdots,b_j]$的最小花费</p>
<p>考虑用$dp_{i,j}$去更新别的状态，分类讨论一下</p>
<ul>
<li><p>删除$a_{i+1}$</p>
<p>没啥好说的删就删吧，$dp_{i,j}+p_{i+1} \rightarrow dp_{i+1}{j}$</p>
</li>
<li><p>不删$a_{i+1}$</p>
<ul>
<li><p>当$a_{i+1} \le b_j$的时候可以转移$dp_{i,j} \rightarrow dp_{i+1,j}$</p>
</li>
<li><p>$a_{i+1}=b_{j+1}$的时候有转移$dp_{i,j} \rightarrow dp_{i+1,j+1}$</p>
</li>
<li><p>如果$a_{i+1}&gt;b_j$且$a_{i+1} \not= b_{j+1}$，在不删除$a_{i+1}$的情况下$dp_{i,j}$无法做任何转移</p>
</li>
</ul>
</li>
</ul>
<p>考虑$dp_i$到$dp_{i+1}$之间发生了什么，不删除$a_{i+1}$的转移相当于整体加一个值，能做$a_{i+1} \le b_j$的那类转移一定是一个区间，并且他们的值与$dp_{i,j}$一样，而$a_{i+1}=b_{j+1}$就是一个单点修改的操作</p>
<p>所以用线段树去维护$dp_i$就好了，<a href="https://paste.ubuntu.com/p/sXQqtx5Z4d/">代码链接</a></p>
<h2 id="G-Substring-Search"><a href="#G-Substring-Search" class="headerlink" title="G. Substring Search"></a>G. Substring Search</h2><p>类似<a href="https://www.luogu.com.cn/problem/P4173">这道题</a>，考虑卷积匹配</p>
<p>定义$f_k=\sum\limits_{i=0}^{m-1}(s_i-t_{k+i})^2(p_{s_i}-t_{k+i})^2$</p>
<p>显然如果$t_{k…k+m-1}$能被匹配那么$f_{k}=0$</p>
<p>把上面这个柿子展开<del><a href="https://www.wolframalpha.com/input/?i=%28p-x%29%5E2%28q-x%29%5E2">WolframAlpha</a>，你值得拥有</del>，翻转构造卷积即可</p>
<p>为了防止被卡，模数取的是$1004535809$</p>
<p>但还是被卡了，只要对每个字符赋一个随机的权值就好了</p>
<p>刚开始写的时候把$s$和$t$搞反了，但问题不大，<a href="https://paste.ubuntu.com/p/RfBXCKtQ9P/">代码链接</a></p>
]]></content>
      <categories>
        <category>Codeforces</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>LuoguP6835 [Cnoi2020]线形生物</title>
    <url>/2020/09/26/LuoguP6835-Cnoi2020-%E7%BA%BF%E5%BD%A2%E7%94%9F%E7%89%A9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6835">Link</a></p>
<p>一起来% <a href="https://www.luogu.com.cn/user/220037">w33z</a>吧！</p>
<a id="more"></a>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>令$d_i$表示$i$向前连的返祖边的条数</p>
<p>先考虑一个DP，令$dp_i$表示点$i$到$n+1$的步数的期望，于是有转移</p>
<script type="math/tex; mode=display">dp_i = \frac{1}{d_i+1}(dp_{i+1} + \sum\limits_{j \leftarrow i} dp_j) + 1</script><p>边界是$dp_{n+1} = 0$，我们想求出$dp_{1}$</p>
<p>不好转移，我们发现与$dp_i$有关的状态有$i$通过返祖边连向的前面的节点以及$dp_{i+1}$</p>
<p>来推推柿子</p>
<script type="math/tex; mode=display">(d_i+1) dp_i = dp_{i+1} + d_i + 1 + \sum\limits_{j \leftarrow i} dp_j</script><script type="math/tex; mode=display">dp_{i+1} = (d_i+1) dp_i - d_i - 1 - \sum\limits_{j \leftarrow i} dp_j</script><p>观察到所有$dp_i$都可以用$dp_1$表示，即$dp_i = k_i dp_0 + b_i$</p>
<p>显然$k_1 = 1, b_1 = 0$，于是我们能递推出$k_i,b_i$，然后得到一个等式$k_{n+1} dp_1 + b_{n+1} = dp_{n+1} = 0$，解方程即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = (ll) a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ll) ans * a % P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= P) x -= P;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x -= y;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += P;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k, b;</span><br><span class="line">    line <span class="keyword">operator</span>+(<span class="keyword">const</span> line &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;add(k, o.k), add(b, o.b)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    line <span class="keyword">operator</span>-(<span class="keyword">const</span> line &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;sub(k, o.k), sub(b, o.b)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    line <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;(ll) k * o % P, (ll) b * o % P&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    line <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="keyword">int</span> &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;k, sub(b, o)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    line <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span> &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;k, add(b, o)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line">line f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> f__k, n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; f__k &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        --u, --v;</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">        ++d[u];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        line tmp = f[i] * (d[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : g[i])</span><br><span class="line">            tmp = tmp - f[j];</span><br><span class="line">        tmp = tmp - d[i] - <span class="number">1</span>;</span><br><span class="line">        f[i + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ll) (P - f[n].b) * mpow(f[n].k, P - <span class="number">2</span>) % P;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
